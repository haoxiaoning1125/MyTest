创建型模式: 处理对象创建
    工厂模式:
        简单工厂模式:
            对不同类的实例创建作一层封装, 由工厂创建需要的对象 (向工厂传递类型)
        工厂方法模式:
            由具体的产品工厂完成创建对象的任务 (向工厂传递实例)
        抽象工厂模式:
            一个抽象工厂是逻辑上的一组工厂方法, 每个工厂方法负责产生不同种类的对象实例
    建造者模式:
        创建一个由多个部分构成的对象, 此对象有不同的表现, 且将对象的构造和表现解耦
    原型模式:
        用于克隆对象, 并允许在被克隆的对象上进行修改, 不影响被克隆对象

结构型模式: 处理一个系统中不同实体(类, 对象)之间的关系
    适配器模式:
        实现两个不兼容接口之间的兼容, 遵从开闭原则
    修饰器模式:
        动态地(在运行时)为一个对象添加额外的功能
    外观模式:
        隐藏系统的内部复杂性, 是在已有复杂系统上实现的抽象层
    享元模式:
        通过为相似对象引入数据共享以最小化内存使用
    模型-视图-控制器模式(MVC):
        模型: 访问数据
        视图: 模型的外在表现
        控制器: 模型和视图之间的连接
    代理模式:
        远程代理: 实际存在于不同地址空间的对象在本地的代理
        虚拟代理: 用于懒初始化, 将一个大计算量对象的创建延迟到真正需要的时候
        保护代理: 控制敏感对象的访问
        引用代理: 在对象被访问时执行额外操作, (引用计数, 线程安全检查)

行为型模式: 处理系统实体之间的通信
    责任链模式:
        用于多个对象处理单个请求:
            存在一个对象链
            开始时将请求发给链中的第一个对象
            对象决定是否处理该请求
            对象将请求发给下一个对象
            重复上述过程直到达到链尾
    命令模式:
        将一个操作封装为一个对象, 调用命令的对象和执行命令的对象解耦
    解释器模式:
        使用宿主语言提供的特性构建一种简单但有用的语言
    观察者模式:
        在一个对象的状态变化时更新与其相关的一组对象
        在运行时, 观察者的数量可变
    状态模式:
        一个或多个有限状态机的实现
    策略模式:
        使用多种算法解决同一个问题, 能够在运行时透明地切换算法(客户端不可见)
        在不存在针对所有数据和情况的完美算法时使用
        例如python: sorted(), list.sort()
    模板模式:
